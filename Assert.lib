Class Assert {
	Static Tests := 0, Failures := 0, Successes := 0
		, Log := []

	SetGroup(name) {
		this.Group := name
	}

	SetLabel(name) {
		this.Label := name
	}

	Test(result, expected, mode, message := "") {
		Local

		this.Tests++

		if (IsObject(result)) {
			result := this.Print(result)
		}

		if (IsObject(expected)) {
			expected := this.Print(expected)
		}

		if (~(mode + (result == expected) - 2)) {  ;* The bitwise operator will return a truthy value for anything but -1.
			this.Successes++

			return (1)
		}
		else {
			this.Failures++

			Static currentGroup

			if (!(this.Group == currentGroup)) {
				currentGroup := this.Group

				stringLength := StrLen(currentGroup), subtract := Ceil(stringLength/2) + 1

				this.Log.Push("`n" . StrReplace(Format("{:0" . 20 - subtract + (stringLength & 1) . "}", 0), "0", "=")
					. Format(" {} ", currentGroup)
					. StrReplace(Format("{:0" . 60 - subtract . "}", 0), "0", "="))
			}

			Static currentLabel

			if (!(this.Label == currentLabel)) {
				currentLabel := this.Label

				stringLength := StrLen(currentLabel), subtract := Ceil(stringLength/2) + 1

				this.Log.Push("`n" . StrReplace(Format("{:0" . 60 - subtract + (stringLength & 1) . "}", 0), "0", "=")
					. Format(" {} ", currentLabel)
					. StrReplace(Format("{:0" . 20 - subtract . "}", 0), "0", "=") . "`n")
			}

			this.Log.Push(Format("`nTest #{}", SubStr("000" . this.Tests, -2)))
			this.Log.Push(Format("`nResult: {}", result))
			this.Log.Push(Format("`nExpected: {}", expected))

			if (!(message == "")) {
				this.Log.Push("`n" . message)
			}

			this.Log.Push("`n")

			return (0)
		}
	}

	IsEqual(result, expected) {
		return (this.Test(result, expected, 1))
	}

	IsNotEqual(result, expected) {
		return (this.Test(result, expected, 0))
	}

	IsTrue(result) {
		return (this.Test(result, 1, 1))
	}

	IsFalse(result) {
		return (this.Test(result, 0, 1))
	}

	IsNull(result) {
		return (this.Test(result, "", 1))
	}

	Report() {
		Local

		report := Format("{} {} completed with a {}% success rate ({} {}).`n", this.Tests, (this.Tests == 1) ? ("test") : ("tests"), Floor((this.Successes/this.Tests)*100), this.Failures, (this.Failures == 1) ? ("failure") : ("failures"))

		for i, entry in this.Log {
			report .= entry
		}

		this.Console(report)
	}

	Print(object) {
		Local

		Static needleRegEx := "S)^0+(?=\d\.?)|(?=\.).*?\K\.?0*$"  ;! RegExReplace(v, "S)^0*(\d+(?:\.(?:(?!0+$)\d)+)?).*", "$1")

		if IsObject(object) {
			for key in object {
				isArray := (key == index++)
			} until (!isArray)

			if (isArray) {
				if (object.Length()) {
					index := object.MinIndex(), maxIndex := object.MaxIndex() + 1 - index  ;* Account for 0-base arrays.

					string := "["

					loop, % maxIndex {  ;* Use `loop` to avoid skipping over empty elements.
						value := object[index++]

						string .= ((IsObject(value)) ? (this.Print(value)) : ((value ~= "[\d\.]+") ? (RegExReplace(value, needleRegEx)) : (Format("""{}""", value)))) . ((A_Index < maxIndex) ? (", ") : ("]"))
					}
				}
				else {
					string := "[]"
				}
			}
			else {
				count := object.Count()

				if (count) {
					string := "{"

					for key, value in object {
						string .= Format("{}: ", (key == Round(key)) ? (key) : (Format("""{}""", key))) . ((IsObject(value)) ? (this.Print(value)) : (((value ~= "[\d\.]+") ? (RegExReplace(value, needleRegEx)) : (Format("""{}""", value))))) . ((A_Index < count) ? (", ") : ("}"))
					}
				}
				else {
					string := "{}"
				}
			}
		}

		return (string)
	}

	Console(output) {
		try {
			DllCall("AttachConsole", "Int", -1) || DllCall("AllocConsole")
			FileAppend, % output . "`n", CONOUT$

			Sleep, 500
			loop {
				Sleep, 50
			} until (A_TimeIdleKeyboard < 50)

			DllCall("FreeConsole")
		}
		catch {
			return (0)
		}

		return (1)
	}
}